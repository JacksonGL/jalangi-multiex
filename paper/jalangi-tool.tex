\documentclass{sig-alternate}

\usepackage{xspace}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{listings}
\usepackage{float}
\usepackage{soul}
\usepackage{multirow}
\usepackage{url}

\floatstyle{boxed}
\restylefloat{figure}
\setlength{\floatsep}{0pt}
\renewcommand{\topfraction}{0.95}
\renewcommand{\textfraction}{0.05}
\renewcommand{\floatpagefraction}{0.95}

\def\jalangi{\textsc{Jalangi}}
\newcommand \dsl [1] {\ensuremath{{\tt #1}}\xspace}
\newcommand \usl [1] {\mbox{\underline{\tt #1}}\xspace}
\newcommand \Sync{\dsl{sync}}
\newcommand \Actual{{\tt getConcrete}}
\newcommand \Shadow{{\tt getSymbolic}}
\newcommand \Enter{\dsl{enter}}
\newcommand \Exit{\dsl{exit}}
\newcommand \analysis{\usl{anlys}}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\bf\tt,
  ndkeywords={anlys, literal, binary, unary, putField,
    getField, conditional, call},
  ndkeywordstyle=\underline,
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\sl,
  stringstyle=\sf,
  morestring=[b]',
  morestring=[b]",
literate={\$}{{\textcolor{blue}{\$}}}1
}

\lstdefinelanguage{pseudo} { 
  	basicstyle=\tt, 
	keywordstyle=\bf\tt,
  	morekeywords= { Object, foreach, to, for, new, while, do, if, then, else, return, caoea, int, in  }, 
    sensitive=false, 
    morecomment=[l]{//}, 
    morecomment=[s]{/*}{*/},
	morestring=[b]"
}

\begin{document}



\conferenceinfo{Under Submission}{Do Not Distribute}

\title{Jalangi: A Tool Framework for Concolic Testing, Selective
  Record-Replay, and Dynamic Analysis of JavaScript}
\numberofauthors{2}

\author{
\alignauthor
Koushik Sen\titlenote{The work of this author was supported in full by
  Samsung Research America.}\\
      \affaddr{EECS Department}\\
      \affaddr{UC Berkeley, CA, USA.}\\
     \affaddr{{\tt\small ksen@cs.berkeley.edu}}
\alignauthor
Swaroop Kalasapur, Tasneem Brutch,  and Simon Gibbs\\
\affaddr{Samsung Research America}\\
\affaddr{75 West Plumeria Drive, San Jose, CA, USA}\\
\affaddr{{\tt\small \{s.kalasapur,t.brutch,s.gibbs\}@sisa.samsung.com}}
}
% 2nd. author
\maketitle
\sloppy

\begin{abstract}
  We describe a tool framework, called \jalangi{}, for dynamic
  analysis and concolic testing of JavaScript programs.  The framework
  is written in JavaScript and allows implementation of various
  heavy-weight dynamic analyses for JavaScript. \jalangi{}
  incorporates two key techniques: 1) selective record-replay, a
  technique which enables to record and to faithfully replay a
  user-selected part of the program, and 2) shadow values and shadow
  execution, which enables easy implementation of heavy-weight dynamic
  analyses such as concolic testing and taint tracking.  \jalangi{}
  works through source-code instrumentation which makes it portable
  across platforms.  \jalangi{} is available at
  \url{https://github.com/SRA-SiliconValley/jalangi} under Apache 2.0
  license.  Our evaluation of \jalangi{} on the SunSpider benchmark
  suite and on five web applications shows that \jalangi{} has an
  average slowdown of 26X during recording and 30X slowdown during
  replay and analysis.  The slowdowns are comparable with slowdowns
  reported for similar tools, such as PIN and Valgrind for x86
  binaries.
\end{abstract}

\section{Introduction}

JavaScript is the language of choice for writing client-side web
applications and is getting increasingly popular for writing mobile
applications (e.g. web apps for Tizen OS and iOS), desktop apps
(e.g. apps for Windows 8 and Gnome Desktop), and server-side
applications (e.g. node.js).  However, there are not that many tools
available for analysis, testing, and debugging of JavaScript
applications.  We have developed a simple yet powerful framework,
called \jalangi{}, for writing heavy-weight dynamic analyses for
JavaScript.  In this paper, we briefly describe the framework and its
usage scenarios.  The framework provides a few useful abstractions and
an API that significantly simplifies implementation of dynamic
analyses for JavaScript.  A detailed description of the techniques
underlying \jalangi{} can be found in~\cite{SBGKfse13}.

\jalangi{} works on any browser or \texttt{node.js}.  We achieve
browser independence through selective source
instrumentation. \jalangi{} can operate even if certain source files
are not instrumented.  An analysis in \jalangi{} works in two-phases.
In the first phase, an instrumented JavaScript application is executed
and recorded on a user selected platform (e.g. mobile chrome running
on Android).  In the second phase, the recorded data is utilized to
perform a user specified dynamic analysis in a desktop environment.

\jalangi{} allows easy implementation of a dynamic analysis through
the support of \emph{shadow values} and \emph{shadow execution}.
\emph{Shadow values} enable us to associate a shadow value with any
value used in the program.  In \jalangi{}, we have implemented several
dynamic analyses using shadow values and execution: 1) concolic
testing, 2) pure symbolic execution, 3) tracking origins of
\texttt{null} and
\texttt{undefined}~\cite{Bond:2007:TBA:1297027.1297057}, 4) detecting
likely type inconsistencies, 5) a simple object allocation profiler,
and 6) a simple dynamic taint analysis.

\section{Technical Details}
\label{sec:technical-details}

In this section, we briefly summarize \jalangi{}'s underlying
techniques.  A detailed discussion of the techniques could be found
in~\cite{SBGKfse13}.  \jalangi{} assumes that the user selects a
subset of the JavaScript source in a web application for
record-replay.  \jalangi{} instruments the user-selected source for
record-replay.  During the \emph{recording} phase, the application is
executed with the instrumented files on a platform of the user's
choice (e.g. a mobile browser or a node.js interpreter).  During
recording, the entire application is executed, i.e. all instrumented
and un-instrumented JavaScript files and native codes get executed.
During the \emph{replay} phase, \jalangi{} only replays the execution
of the instrumented sections.  This asymmetry of execution in the two
phases enables one to record an execution of a JavaScript application
on an actual platform (e.g. a mobile browser) and then replay the
execution for the purpose of debugging on a desktop JavaScript engine,
such as node.js or a JavaScript engine embedded in an IDE.  Moreover,
during replay, since we avoid the execution of un-instrumented code
and native code, we can easily implement various dynamic analyses that
depend on shadow values and shadow executions.

A trivial way to perform faithful record-replay of an execution is to
record every value loaded from memory during an execution and use
those values for corresponding memory loads in the replay phase.  This
approach has two challenges: 1) How do we record values of objects and
functions?  2) How do we replay an execution when an un-instrumented
function or a native function, such as the JavaScript event
dispatcher, calls an instrumented function?  Note that we do not allow
the execution of un-instrumented and native functions during the
replay phase.  Therefore, we need an alternative mechanism to execute
instrumented functions that are being invoked by un-instrumented
functions during recording.  We address the first challenge by
associating a unique numerical identifier with every object and
function and by recording the value of those unique identifiers.  We
address the second challenge by explicitly recording and calling
instrumented functions that are being invoked from un-instrumented
functions or are dispatched by the JavaScript event dispatcher.


In \jalangi{}, we avoid recording of every load of memory.  \emph{This
  is based on the observation that if we can compute the value of a
  memory load during the replay phase by solely executing the
  instrumented code, then we do not need to record the value of the
  load.}  In order to determine if the value of a memory load needs to
be recorded, \jalangi{} maintains a shadow memory during the recording
phase.  The shadow memory is updated along with the actual memory
during the execution of instrumented code.  Execution of
un-instrumented and native code does not update the shadow memory.
During the load of a memory location in the recording phase, if
\jalangi{} finds any difference between the value of the actual memory
being loaded and the value stored in the corresponding shadow memory,
\jalangi{} records the value of such memory loads. This ensures that
correct values are available during the replay phase.

In shadow execution, \jalangi{} allows the replacement of any value
used in the execution by an \emph{annotated value}.  The annotated
value can carry extra information about the actual value.  For
example, an annotated value can carry taint information in a taint
analysis or a symbolic expression describing the actual value in
symbolic execution.  In \jalangi{}, we denote an annotated value using
an object of type \texttt{ConcolicValue}.  An object of type
\texttt{ConcolicValue} has two fields: the field \texttt{concrete}
stores the actual value and the field \texttt{symbolic} stores the
shadow value, i.e. extra information about the actual value.  A value,
say $v$, in JavaScript can be associated with shadow value, say $s$,
by simply replacing $v$ by \texttt{new ConcolicValue}$(v, s)$.  The
projection function $\Actual(v)$ returns the actual value of $v$, if
$v$ is an annotated value and returns $v$ otherwise.  Similarly, the
projection function $\Shadow(v)$ returns the shadow value associated
with $v$ if $v$ is an annotated value and returns \texttt{undefined}
otherwise.

\section{Dynamic Analyses}
\label{sec:dynamic-analyses}

In \jalangi{}, we have implemented the following dynamic analyses:

\begin{itemize}
\item Concolic testing~\cite{dart,cute}: Concolic testing performs
  symbolic execution along a concrete execution path, generates a
  logical formula denoting a constraint on the input values, and
  solves a constraint to generate new test inputs that would execute
  the program along previously unexplored paths.  Our implementation
  of concolic testing supports constraints over integer, string, and
  object types and \emph{novel type constraints.}  We introduced type
  constraints to handle the dynamic nature of JavaScript---the type of
  an input variable could be different for different feasible
  execution paths of the program.
\item Pure symbolic execution: Pure symbolic execution executes the
  program symbolically and never restarts the program for the purpose
  of backtracking.  It checkpoints the state before executing a branch
  statement, executes one branch, and later backtracks with the
  checkpointed state to explore the other branch.  For small programs,
  pure symbolic execution avoids time wastage due to repeated
  restarts.
\item Tracking origins of \texttt{null} and
  \texttt{undefined}~\cite{Bond:2007:TBA:1297027.1297057}: This
  analysis records source code locations where null and undefined
  values come into existence and reports them if they cause an error.
  Whenever there is an error due to such literals, such as accessing
  the field of a null value, the shadow value of the literal is
  reported to the user.  Such a report helps the programmer to easily
  identify the origin of the null value.
\item Detecting Likely Type Inconsistencies: The dynamic analysis
  checks if an object created at a given program location can assume
  multiple inconsistent type.  It computes the types of object and
  function values created at each definition site in the program.  If
  an object or a function value defined at a program location has been
  observed to assume more than one type during the execution, the
  analysis reports the program location along with the observed types.
  Sometimes these kind of type inconsistencies could point us to a
  potential bug in the program.  We have noticed such issues in two
  SunSpider benchmark programs.
\item Simple Object Allocation Profiler: This dynamic analysis records
  the number of objects created at a given allocation site and how
  often the object has been accessed.  It reports if the objects
  created at a given allocation site are read-only or a constant.  It
  also reports the maximum and average difference between the object
  creation time and the most recent access time of the object .  If an
  allocation site creates too many contant objects, then it could lead
  to memory inefficiency.  We have found such a problem in one of the
  web applications in our benchmark suite.
\item Dynamic taint analysis~\cite{songndss05}: A dynamic taint
  analysis is a form of information flow analysis which checks if
  information can flow from a specific set of memory locations, called
  sources, to another set of memory locations, called sinks.  We have
  implemented a simple form of dynamic taint analysis in \jalangi{}.
  In the analysis, we treat read of any field of any object, which has
  not previously been written by the instrumented source, as a source
  of taint.  We treat any read of a memory location that could change
  the control-flow of the program as a sink.  We attach taint
  information with the shadow value of an actual value.
\end{itemize}


\section{Implementation}
\label{sec:implementation}

\jalangi{} is available at
\url{https://github.com/SRA-SiliconValley/jalangi}.  We have
implemented \jalangi{} in JavaScript.

\begin{table*}
\begin{minipage}{0.28\textwidth}
\begin{tabular}{|r|}
\hline\\
{\scriptsize
\begin{lstlisting}
var a = {x:1, y:2};

function f2 (c) {
 if (c > 5 ) 
   a.y = a.x + c;
 return c;
}

f1(12);
\end{lstlisting}
}\\
\hline
\end{tabular}
\caption{Sample Code Before Instrumentation}
\label{tab:original}
\end{minipage}
\begin{minipage}{0.71\textwidth}
\begin{tabular}{|r|}
\hline\\
{\scriptsize
\begin{lstlisting}
  J$.U(iid, op, oprnd); // wrapper for unary operations
  J$.B(iid, op, left, right); // wrapper for binary operations
  J$.C(iid, cond); // wrapper for conditional branches
  J$.C1(iid, key); // wrapper for the key of a switch statement
  J$.C2(iid, case); // wrapper for a case label of a switch
  J$._();  // returns last value passed to J$.C

  J$.H(iid, val); // wrapper for hash used in for-in
  J$.I(val); // ignore argument
  J$.G(iid, base, offset); // wrapper for getField
  J$.P(iid, base, offset, val); // wrapper for putField
  J$.R(iid, name, val); // wrapper for local variable read
  J$.W(iid, name, val, lhs); // wrapper for local variable write
  J$.Niid, name, val, isArgument); // wrapper for initialization
  J$.T(iid, val, type); // wrapper for a object/function/regexp/array literal
  J$.F(iid, f, isConstructor); // wrapper for a function call
  J$.M(iid, base, offset, isConstructor); // wrapper for a method call
  J$.A(iid, base, offset, op); // wrapper for +=, -=, ...
  J$.Fe(iid, val, dis); // callback at function entry
  J$.Fr(iid); // callback at function return
  J$.Se(iid, val); // callback at script entry
  J$.Sr(iid); // callback at script exit
  J$.Rt(iid, val); // wrapper for value being returned
  J$.Ra();  // callback for grabbing return value

  J$.makeSymbolic(symbol, val);  // make a value symbolic
  J$.addAxiom(formula, branch);  // adds a constraint to the path constraint
  J$.endExecution(); // callback at the end of an execution

\end{lstlisting}
}\\
\hline
\end{tabular}
\caption{Callback Functions from Instrumented Code}
\label{tab:callbacks}
\end{minipage}
\end{table*}

\begin{table*}
\begin{tabular}{|r|}
\hline\\
{\scriptsize
\begin{lstlisting}
if (typeof window === 'undefined') {
  require('/user/jalangi/src/js/analysis.js');
  require('/user/jalangi/src/js/InputManager.js');
  require('/user/jalangi/src/js/instrument/esnstrument.js');
  require(process.cwd() + '/inputs.js');
}
{
  try {
    J$.Se(73, 'tests/unit/instrument-small_jalangi_.js');
    J$.N(77, 'a', a, false);
    J$.N(85, 'f2', J$.T(81, f2, 12), false);
    var a = J$.W(17, 'a', J$.T(13, {
      x: J$.T(5, 1, 22),
      y: J$.T(9, 2, 22)
    }, 11), a);
    function f2(c) {
      jalangiLabel0:
        while (true) {
          try {
            J$.Fe(49, arguments.callee, this);
            J$.N(53, 'arguments', arguments, true);
            J$.N(57, 'c', c, true);
            if (J$.C(4, J$.B(6, '>', J$.R(21, 'c', c), J$.T(25, 5, 22))))
              J$.P(45,J$.R(29,'a',a),'y',J$.B(10,'+',J$.G(37,J$.R(33,'a',a),'x'),J$.R(41,'c',c)));
            return J$.Rt(97, J$.R(49, 'c', c));
          } catch (J$e) {
            throw J$e;
          } finally {
            if (J$.Fr(93))
              continue jalangiLabel0;
            else
              return J$.Ra();
          }
        }
    }
    J$.F(69,J$.I(typeof f1==='undefined'?J$.R(61,'f1',undefined):J$.R(61,'f1',f1)),false)(J$.T(65,12,22));
  } catch (J$e) {
    throw J$e;
  } finally {
    J$.Sr(89);
  }
}
// JALANGI DO NOT INSTRUMENT

//@ sourceMappingURL=instrument-small_jalangi_.js.map
\end{lstlisting}
}\\
\hline
\end{tabular}
\caption{After Instrumentation of  Code in Table~\ref{tab:original}}
\label{tab:instrumented}
\end{table*}

\jalangi{} operates by instrumenting JavaScript code.
Table~\ref{tab:instrumented} shows code obtained after instrumentation
of the code in Table~\ref{tab:original}.  During instrumentation,
\jalangi{} inserts various callback functions from the \jalangi{}
library.  The callback functions are listed in
Table~\ref{tab:callbacks}.  These functions wrap the various
operations in JavsScript.  The selective record-replay engine of
\jalangi{} is implemented by defining these callback functions.

\jalangi{} exposes the instrumentation library as a function
\texttt{instrumentCode}.  This enables us also to dynamically
instrument any code that is created and evaluated at runtime.  For
example, we modify any call to \texttt{eval(s)} to
\texttt{eval(instrumentCode(s))}.
During recording phase, \jalangi{} generates a \texttt{trace} array
which contains all recorded values needed for replay.  \jalangi{}
serializes the \texttt{trace} array in JSON format.  

\section{Performance of  jalangi}
\label{sec:performance-jalangi}

\begin{table}
{\scriptsize
\begin{center}
\begin{tabular}{|l|r|r|r|r|r|r|} \hline
\multirow{2}{*}{Benchmark} & \multirow{2}{*}{LOC} & \scriptsize{Records} & \scriptsize{SlowR} &
\multicolumn{3}{|c|}{\scriptsize{ Slowdown in Replay}}\\
& & & & empty & taint & track \\
\hline
3d-cube & 339 & 3670 & 18.33  & 25.16 & 28.67 & 26 \\
3d-morph& 56 & 6 & 18.2 & 33.2 & 35.83 & 33.6 \\
3d-raytrace& 443 & 79791 & 38.17 & 29.05 & 30.5 & 35\\
b-trees& 52 & 146048 & 57.8 & 40 & 42.4 & 42.8\\
fannkuch& 68 & 246 & 40.6 & 76.4 & 73 & 80.4 \\
nbody& 170 & 78 & 19 & 25.8& 25.67 & 24.16\\
nsieve& 39 & 5 & 16.4 & 23.6 & 30 & 24.2\\
3bit-in-byte& 38 & 1 & 16.6& 29 & 31 & 30.2 \\
bits-in-byte& 26 & 1 & 25 & 25 & 51.4 & 47 \\
bitwise-and& 31 & 1 & 12.83 & 21.83 & 29.2 & 26.2\\
controlflow& 25 & 1 & 20 & 33.2 & 34.6 & 28.33\\
crypto-md5& 288 & 42 & 12 & 18 & 22.2 & 22\\
crypto-sha1& 225 & 52 & 13.4& 19.4 & 21 & 21.2\\
date-tofte& 300 & 32018 & 92.16 & 92.67 & 92.83 & 95.5\\
date-xparb& 418 & 95715 & 29.83 & 21 & 22.67 & 25.67\\
math-cordic& 101 & 8 & 29.6 & 35.6 & 45.4 & 40.17\\
partial-sums& 33 & 5 & 14.6 & 23.4 & 22.16& 23.8\\
spectral-norm& 51 & 15 & 19.8& 25.2 & 29.2 & 29.4\\
regexp-dna& 1714 & 42 &2 & 4 & 3.17 & 3.8\\
string-fasta& 90 & 56947 & 40.17 & 30.33 & 34.5 & 38.6\\
string-tagcloud& 266 & 117577 & 51.42 & 50.86 & 44 & 42.8\\
string-unpack& 67 & 193057 & 29.88 & 13.25 & 13.75 & 17\\
nsieve-bits& 35 & 3 & 20 & 36.6 & 45.4 & 40 \\
crypto-aes& 425 & 23926  & 19 & 21 & 23.67 & 23 \\
string-validate& 90 & 60 & 1.5 & 1.5 & 1.4 & 1.5\\
string-base64& 136 & 40965 & 25 & 27.2 & 29.6 & 29.2\\
\hline 
annex& 9663 & 87623 & - & - & - & - \\
calculator& 787 & 1288 & - & - & - & - \\
 go& 10,039 & 114609 & - & - & - & - \\
tenframe& 1491 &4656 & - & - & - & - \\
shopping& 5397 & 1144 & - & - & - & - \\
\hline 
\end{tabular}
\end{center}}
\caption{Results: ``Records'' column reports number of values
  recorded, ``SlowR'' reports
  slowdown during recording compared to normal execution.}
\label{tab:results}
\end{table}

We ran \jalangi{}'s record-replay on 26 programs in the JavaScript
SunSpider (\url{http://www.webkit.org/perf/sunspider/sunspider.html})
benchmark suite and on five web apps written for the Tizen OS using
HTML5/JavaScript
(\url{https://developer.tizen.org/downloads/sample-web-applications}).
Table~\ref{tab:results} shows the overhead associated with the record
phase and with the three dynamic analyses: no analysis (denoted by
\emph{empty}), tracking origins of null and undefined (denoted by
\emph{track}), and a taint analysis (denoted by \emph{taint}).  We
also report the number of values we recorded for each benchmark
program.  The experiments were performed on a laptop with 2.3 GHz
Intel Core i7 and 8 GB RAM.  We ran the web apps on Chrome 25 and
performed the replay executions on node.js 0.8.14.

We didn't measure the slowdown of the web apps because these are
mostly interactive applications.  For the SunSpider benchmark suite,
we observed an average slowdown of 26X during the recording phase with
a minimum of 1.5X and a maximum of 93X.  On the \emph{empty} analysis
during the replay phase, we observed an average slowdown of 30X with a
minimum of 1.5X and a maximum of 93X.  \emph{Track} analysis showed an
average slowdown of 32.75X with a minimum of 1.5X and a maximum of
96X.

\section{Related Work}
\label{sec:related-work}

To our best knowledge \jalangi{} is the first dynamic analysis
framework for JavaScript.  There are few tools that could perform
record-replay of JavaScript programs.
JSBench~\cite{Richards:2011:ACJ:2048066.2048119} uses record-replay
mechanisms to create JavaScript benchmarks.
Mugshot~\cite{Mickens:2010:MDC:1855711.1855722} is captures all events
to deterministically replay executions of web applications.
Ripley~\cite{Vikram:2009:RAS:1653662.1653685} replicates execution of
a client-side JavaScript program on a server side replica.


\section{Conclusion}
\label{sec:conclusion}

\jalangi{} has taken care of various challenging details of JavaScript.  One
can easily implement a dynamic analysis in the \jalangi{} framework
without worrying about the worrysome corners of JavaScript.  We expect that
\jalangi{} will facilitate future research on dynamic analysis of
JavaScript. 

% \subsubsection*{Record and replay a web application}
% \label{sec:record-replay-web}

% First start a HTTP server by running the following command. The command starts a simple Python based http server.

% \begin{verbatim}
% python -m SimpleHTTPServer \&
% \end{verbatim}
% Then one needs to manually instrument the JavaScript files that
% require analysis. The \texttt{index.html} also needs to edited so that
% it loads the \jalangi{} library files and the instrumented files.

% \begin{verbatim}
% node src/js/instrument/esnstrument.js tests/tizen/annex/js/annex.js
% \end{verbatim}
% Finally launch the jalangi server and the html page by running

% \begin{verbatim}
% ./scripts/rrserver http://127.0.0.1:8000/tests/tizen/annex/index_jalangi_.html
% \end{verbatim}

% You can now play the game for sometime. Try two moves. This will
% generate a jalangi\_trace1 in the current directory. You can run a
% dynamic analysis on the trace file by issuing the following commands.

{\small
\bibliographystyle{abbrv}
\bibliography{jalangi}
}
\end{document}

